/*===========================================================================================*/
/* Модуль выполнения арифметических операций над числами с естественным размещением запятой. */
/* Вычисления производятся с точностью IADFCAPACITY (iadf.h) разрядов.                       */
/*===========================================================================================*/
#include <windows.h>
#include "iaarithm.h"
#include "iastring.h"
#include "../iadf/iadf.h"
#define DFSBUFSZ (IADFCAPACITY+4)
/* Размер буфера исчислен исходя из IADFCAPACITY значащих цифр, знака числа, */
/* неявного нуля целой части для чисел из диапазона +/-[0.00...1, 0.99...9], */
/* разделителя целой и дробной части и символа-ограничителя строки '\0'.     */
static void BufToDisplay (LPTSTR s, const char* buf);
/*==================================================*/
/* Сложение: x = y + x                              */
/* Вызов: y - первое слагаемое,                     */
/*        x - второе слагаемое.                     */
/* Возврат: признак результата выполнения операции, */
/*        x - сумма y и x.                          */
/*==================================================*/
enum EOpRes OpAdd (LPTSTR x, LPCTSTR y)
{
	struct IADF df1, df2;
	char buf[DFSBUFSZ];	/* буфер для представления результата в текстовом виде */
	enum EOpRes res;
	int r;
	/* Преобразование текстовых записей десятичных дробей во внутренний формат. */
	iadfInit (&df1, y);
	iadfInit (&df2, x);
	/* Выполнение операции. */
	r = iadfAdd (&df1, &df2);
	/* Преобразование результата из внутреннего формата в текстовую запись. */
	iadfToStr (&df1, buf, DFSBUFSZ);
	BufToDisplay (x, buf);
	return r? OPOVR: OPOK;
}
/*==================================================*/
/* Вычитание: x = y - x                             */
/* Вызов: y - уменьшаемое,                          */
/*        x - вычитаемое.                           */
/* Возврат: признак результата выполнения операции, */
/*        x - разность y и x.                       */
/*==================================================*/
enum EOpRes OpSub (LPTSTR x, LPCTSTR y)
{
	struct IADF df1, df2;
	char buf[DFSBUFSZ];	/* буфер для представления результата в текстовом виде */
	enum EOpRes res;
	int r;
	/* Преобразование текстовых записей десятичных дробей во внутренний формат. */
	iadfInit (&df1, y);
	iadfInit (&df2, x);
	/* Выполнение операции. */
	r = iadfSub (&df1, &df2);
	/* Преобразование результата из внутреннего формата в текстовую запись. */
	iadfToStr (&df1, buf, DFSBUFSZ);
	BufToDisplay (x, buf);
	return r? OPOVR: OPOK;
}
/*==================================================*/
/* Умножение: x = y * x                             */
/* Вызов: x - первый множитель,                     */
/*        y - второй множитель.                     */
/* Возврат: признак результата выполнения операции, */
/*        x - произведение y на x.                  */
/*==================================================*/
enum EOpRes OpMul (LPTSTR x, LPCTSTR y)
{
	struct IADF df1, df2;
	char buf[DFSBUFSZ];	/* буфер для представления результата в текстовом виде */
	enum EOpRes res;
	int r;
	/* Преобразование текстовых записей десятичных дробей во внутренний формат. */
	iadfInit (&df1, y);
	iadfInit (&df2, x);
	/* Выполнение операции. */
	r = iadfMul (&df1, &df2);
	/* Преобразование результата из внутреннего формата в текстовую запись. */
	iadfToStr (&df1, buf, DFSBUFSZ);
	BufToDisplay (x, buf);
	return r? OPOVR: OPOK;
}
/*==================================================*/
/* Деление: x = y / x                               */
/* Вызов: y - делимое,                              */
/*        x - делитель.                             */
/* Возврат: признак результата выполнения операции, */
/*        x - частное y и x.                        */
/*==================================================*/
enum EOpRes OpDiv (LPTSTR x, LPCTSTR y)
{
	struct IADF df1, df2;
	char buf[DFSBUFSZ];	/* буфер для представления результата в текстовом виде */
	enum EOpRes res;
	int r;
	/* Преобразование текстовых записей десятичных дробей во внутренний формат. */
	iadfInit (&df1, y);
	iadfInit (&df2, x);
	/* Выполнение операции. */
	r = iadfDiv (&df1, &df2);
	/* Преобразование результата из внутреннего формата в текстовую запись. */
	iadfToStr (&df1, buf, DFSBUFSZ);
	BufToDisplay (x, buf);
	return r == 2? OPERR: r == 1? OPOVR: OPOK;
}
/*===========================================================*/
/* Перенос информации из текстового буфера в строку дисплея. */
/* Вызов: s - указатель на строку дисплея,                   */
/*        buf - указатель на буфер.                          */
/*===========================================================*/
static void BufToDisplay (LPTSTR s, const char* buf)
{
	int i, j;
	int d;		/* количество обработанных цифр */
	char c;
	/* Копирование строки, содержащей не более IADFCAPACITY цифр. */
	i = j = d = 0;
	do {
		c = buf[i++];
		if ('0' <= c && c <= '9') {
			if (d < IADFCAPACITY) {
				s[j++] = (TCHAR)c;
				d++;
			}
		}
		else
			s[j++] = (TCHAR)c;
	} while (c);
	/* Отсечение от строки незначащих нулей. */
	j--;	/* переход к символу-ограничителю строки */
	do {
		j--;
	} while (s[j] == (TCHAR)'0');
	s[j + 1] = (TCHAR)'\0';
	/* Исправление "-0," на "0,". */
	if (!StrCmp (s, TEXT ("-0,")))
		StrCpy (s, TEXT ("0,"));
}
